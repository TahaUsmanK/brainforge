/**
 * Code Generator for BrainForge and standard Brainfuck
 */
import type { TranspilerOptions } from "../../types/options"
import type { Logger } from "../../utils/Logger"
import type { MemoryManager } from "../memory/MemoryManager"
import type { StdlibManager } from "../stdlib/StdlibManager"
import type { IntermediateRepresentation } from "../../types/results"
import { CommandType, InstructionType } from "../../types/enums"

/**
 * Generates BrainForge and standard Brainfuck code from IR
 */
export class CodeGenerator {
  /** Transpiler options */
  private options: TranspilerOptions

  /** Logger instance */
  private logger: Logger

  /** Memory manager */
  private memoryManager: MemoryManager

  /** Standard library manager */
  private stdlibManager: StdlibManager

  /**
   * Creates a new code generator
   *
   * @param options - Transpiler options
   * @param logger - Logger instance
   * @param memoryManager - Memory manager
   * @param stdlibManager - Standard library manager
   */
  constructor(options: TranspilerOptions, logger: Logger, memoryManager: MemoryManager, stdlibManager: StdlibManager) {
    this.options = options
    this.logger = logger
    this.memoryManager = memoryManager
    this.stdlibManager = stdlibManager
  }

  /**
   * Generates BrainForge code from IR
   *
   * @param ir - Intermediate Representation
   * @returns Generated BrainForge code
   */
  generateCode(ir: IntermediateRepresentation): string {
    this.logger.debug("Generating BrainForge code")

    let bfCode = ""

    // Add header comment
    bfCode += `// Generated by BrainForge Transpiler v1.1.0\n`
    bfCode += `// Source language: ${this.options.sourceLanguage}\n`
    bfCode += `// Optimization level: ${this.options.optimizationLevel}\n`
    bfCode += `// Memory model: ${this.options.memoryModel}\n\n`

    // Initialize memory if needed
    if (ir.variables.size > 0) {
      bfCode += "// Initialize memory\n"
      const memSize = Math.max(30, this.memoryManager.getNextMemoryAddress())
      bfCode += "[-]".repeat(memSize) + "\n\n"
    }

    // Process instructions
    for (const instruction of ir.instructions) {
      switch (instruction.type) {
        case InstructionType.COMMENT:
          bfCode += `// ${instruction.text}\n`
          break

        case InstructionType.SET_VALUE:
          bfCode += `// Set value at address ${instruction.target}\n`
          bfCode += this.generateSetValueCode(instruction)
          break

        case InstructionType.COPY_VALUE:
          bfCode += `// Copy value from address ${instruction.source} to ${instruction.target}\n`
          bfCode += this.generateCopyValueCode(instruction)
          break

        case InstructionType.PRINT:
          bfCode += `// Print value\n`
          bfCode += this.generatePrintCode(instruction)
          break

        case InstructionType.BINARY_OPERATION:
          bfCode += `// Binary operation: ${instruction.operator}\n`
          bfCode += this.generateBinaryOperationCode(instruction)
          break

        case InstructionType.CALL_FUNCTION:
          bfCode += `// Call function: ${instruction.function}\n`
          bfCode += this.generateFunctionCallCode(instruction)
          break

        case InstructionType.CALL_METHOD:
          bfCode += `// Call method: ${instruction.object}.${instruction.method}\n`
          bfCode += this.generateMethodCallCode(instruction)
          break

        // Handle console.log specifically
        case "ConsoleLog":
          bfCode += `// Console.log\n`
          bfCode += this.generateConsoleLogCode(instruction)
          break

        case InstructionType.CREATE_ARRAY:
          bfCode += `// Create array with ${instruction.elements.length} elements\n`
          bfCode += this.generateCreateArrayCode(instruction)
          break

        case InstructionType.CREATE_OBJECT:
          bfCode += `// Create object with ${instruction.properties.length} properties\n`
          bfCode += this.generateCreateObjectCode(instruction)
          break

        case InstructionType.LABEL:
          bfCode += `// Label: ${instruction.name}\n`
          bfCode += `${CommandType.MEMORY_MANAGEMENT}label:${instruction.name}\n`
          break

        case InstructionType.JUMP:
          bfCode += `// Jump to ${instruction.target}\n`
          bfCode += `${CommandType.MEMORY_MANAGEMENT}jump:${instruction.target}\n`
          break

        case InstructionType.CONDITIONAL_JUMP:
          bfCode += `// Conditional jump\n`
          bfCode += this.generateConditionalJumpCode(instruction)
          break

        case InstructionType.IF_CONDITION:
          bfCode += `// If condition\n`
          bfCode += this.generateIfConditionCode(instruction)
          break

        case InstructionType.RETURN:
          bfCode += `// Return\n`
          bfCode += this.generateReturnCode(instruction)
          break

        case InstructionType.IMPORT:
          bfCode += `// Import from ${instruction.source}\n`
          bfCode += `${CommandType.IMPORT}${instruction.source}\n`
          break

        case InstructionType.EXPORT:
          bfCode += `// Export ${instruction.names.join(", ")}\n`
          break

        case InstructionType.UPDATE_VARIABLE:
          bfCode += `// Update variable: ${instruction.operator}\n`
          bfCode += this.generateUpdateVariableCode(instruction)
          break

        default:
          this.logger.warn(`Unknown instruction type: ${instruction.type}`)
          break
      }
    }

    // If no instructions were processed, add a simple "Hello, World!" program
    if (ir.instructions.length === 0) {
      bfCode += this.generateDefaultHelloWorld()
    }

    this.logger.debug("BrainForge code generation complete")
    return bfCode
  }

  /**
   * Generates a default "Hello, World!" program if no instructions are present
   *
   * @returns BrainForge code for "Hello, World!"
   */
  private generateDefaultHelloWorld(): string {
    let code = "// Default Hello World program\n"

    // "Hello, World!" in BrainForge
    const message = "Hello, World!"

    for (let i = 0; i < message.length; i++) {
      const charCode = message.charCodeAt(i)
      code += `[-]${"+".repeat(charCode)}.\n`
    }

    return code
  }

  /**
   * Generates BrainForge code for console.log
   *
   * @param instruction - Console.log instruction
   * @returns Generated BrainForge code
   */
  private generateConsoleLogCode(instruction: any): string {
    let code = ""

    // Handle different argument types
    if (instruction.args && instruction.args.length > 0) {
      for (const arg of instruction.args) {
        if (arg.type === "Literal") {
          if (typeof arg.value === "string") {
            // Output string literal character by character
            for (let i = 0; i < arg.value.length; i++) {
              const charCode = arg.value.charCodeAt(i)
              code += `[-]${"+".repeat(charCode)}.\n`
            }
          } else if (typeof arg.value === "number") {
            // Convert number to string and output
            const numStr = arg.value.toString()
            for (let i = 0; i < numStr.length; i++) {
              const charCode = numStr.charCodeAt(i)
              code += `[-]${"+".repeat(charCode)}.\n`
            }
          } else if (typeof arg.value === "boolean") {
            // Output "true" or "false"
            const boolStr = arg.value ? "true" : "false"
            for (let i = 0; i < boolStr.length; i++) {
              const charCode = boolStr.charCodeAt(i)
              code += `[-]${"+".repeat(charCode)}.\n`
            }
          }
        } else if (arg.type === "Identifier") {
          // Get variable address and output its value
          const varInfo = this.memoryManager.getMemoryAddress(arg.name)
          if (varInfo !== undefined) {
            code += `${">".repeat(varInfo)}.\n${"<".repeat(varInfo)}\n`
          }
        }
      }
    }

    return code
  }

  /**
   * Generates BrainForge code for setting a value
   *
   * @param instruction - SetValue instruction
   * @returns Generated BrainForge code
   */
  private generateSetValueCode(instruction: any): string {
    let code = ""

    // Move to target address
    code += ">".repeat(instruction.target)

    // Clear cell
    code += "[-]"

    // Set value
    if (instruction.value !== undefined && instruction.value !== null) {
      if (typeof instruction.value === "number") {
        // For numbers, add the value (capped at 255 for 8-bit cells)
        const value = Math.min(Math.abs(instruction.value) % 256, 255)
        code += "+".repeat(value)

        // Handle negative numbers
        if (instruction.value < 0) {
          code += CommandType.BITWISE_OPERATION // BrainForge extension for negation
        }
      } else if (typeof instruction.value === "string") {
        // For strings, use the BrainForge string literal command
        code += `${CommandType.STRING_LITERAL}${instruction.value}${CommandType.STRING_LITERAL}`
      } else if (typeof instruction.value === "boolean") {
        // For booleans, set 1 for true, 0 for false
        if (instruction.value) {
          code += "+"
        }
      }
    }

    // Move back to start
    code += "<".repeat(instruction.target)

    return code + "\n"
  }

  /**
   * Generates BrainForge code for copying a value
   *
   * @param instruction - CopyValue instruction
   * @returns Generated BrainForge code
   */
  private generateCopyValueCode(instruction: any): string {
    // Use variable access command for cleaner code
    return `${CommandType.VARIABLE_ACCESS}copy:${instruction.source}:${instruction.target}\n`
  }

  /**
   * Generates BrainForge code for printing a value
   *
   * @param instruction - Print instruction
   * @returns Generated BrainForge code
   */
  private generatePrintCode(instruction: any): string {
    let code = ""

    if (instruction.sourceType === "Variable" && instruction.source !== undefined) {
      // Move to source address
      code += ">".repeat(instruction.source)

      // Output value
      code += "."

      // Move back to start
      code += "<".repeat(instruction.source)
    } else if (instruction.sourceType === "Literal" && instruction.value !== undefined) {
      // For literal values
      if (typeof instruction.value === "number") {
        // Convert number to ASCII and print
        const charCode = Math.min(instruction.value, 255)
        code += "[-]" + "+".repeat(charCode) + ".[-]"
      } else if (typeof instruction.value === "string") {
        // Print each character
        for (let i = 0; i < instruction.value.length; i++) {
          const charCode = instruction.value.charCodeAt(i)
          code += "[-]" + "+".repeat(Math.min(charCode, 255)) + "."
        }
        code += "[-]"
      } else if (typeof instruction.value === "boolean") {
        // Print 1 for true, 0 for false
        code += "[-]"
        if (instruction.value) {
          code += "+"
        }
        code += ".[-]"
      }
    }

    return code + "\n"
  }

  /**
   * Generates BrainForge code for binary operations
   *
   * @param instruction - BinaryOperation instruction
   * @returns Generated BrainForge code
   */
  private generateBinaryOperationCode(instruction: any): string {
    // Use the BrainForge operation command for cleaner code
    let code = `${CommandType.VARIABLE_ACCESS}op:${instruction.operator}:`

    // Left operand
    if (instruction.leftAddress !== undefined) {
      code += `addr:${instruction.leftAddress}`
    } else if (instruction.leftValue !== undefined) {
      code += `val:${instruction.leftValue}`
    }

    code += ":"

    // Right operand
    if (instruction.rightAddress !== undefined) {
      code += `addr:${instruction.rightAddress}`
    } else if (instruction.rightValue !== undefined) {
      code += `val:${instruction.rightValue}`
    }

    code += `:${instruction.result}\n`

    return code
  }

  /**
   * Generates BrainForge code for function calls
   *
   * @param instruction - CallFunction instruction
   * @returns Generated BrainForge code
   */
  private generateFunctionCallCode(instruction: any): string {
    // Check if it's a standard library function
    const stdlibFunc = this.stdlibManager.getFunction(instruction.function)

    if (stdlibFunc) {
      // Process arguments
      const args = instruction.arguments
        .map((arg: any) => {
          if (arg.type === "Literal") {
            return arg.value
          } else if (arg.type === "Variable") {
            return arg.name
          }
          return null
        })
        .filter((arg: any) => arg !== null)

      // Call standard library function
      let code = stdlibFunc.code(...args)

      // Store result if needed
      if (instruction.result !== undefined) {
        code += `${CommandType.VARIABLE_ACCESS}store:${instruction.result}\n`
      }

      return code
    } else {
      // Custom function call using BrainForge function call command
      let code = `${CommandType.FUNCTION_CALL}${instruction.function}(`

      // Add arguments
      const args = instruction.arguments
        .map((arg: any) => {
          if (arg.type === "Literal") {
            return `val:${arg.value}`
          } else if (arg.type === "Variable") {
            return `var:${arg.name}`
          }
          return "null"
        })
        .join(",")

      code += `${args})`

      // Store result if needed
      if (instruction.result !== undefined) {
        code += `${CommandType.VARIABLE_ACCESS}store:${instruction.result}`
      }

      return code + "\n"
    }
  }

  /**
   * Generates BrainForge code for method calls
   *
   * @param instruction - CallMethod instruction
   * @returns Generated BrainForge code
   */
  private generateMethodCallCode(instruction: any): string {
    // Special handling for console.log
    if (instruction.object === "console" && instruction.method === "log") {
      return this.generateConsoleLogCode({
        args: instruction.arguments,
      })
    }

    // Check if it's a standard library method
    const methodKey = `${instruction.object}.${instruction.method}`
    const stdlibMethod = this.stdlibManager.getMethod(methodKey)

    if (stdlibMethod) {
      // Process arguments
      const args = instruction.arguments
        .map((arg: any) => {
          if (arg.type === "Literal") {
            return arg.value
          } else if (arg.type === "Variable") {
            return arg.name
          }
          return null
        })
        .filter((arg: any) => arg !== null)

      // Call standard library method
      let code = stdlibMethod.code(...args)

      // Store result if needed
      if (instruction.result !== undefined) {
        code += `${CommandType.VARIABLE_ACCESS}store:${instruction.result}\n`
      }

      return code
    } else {
      // Custom method call using BrainForge method call command
      let code = `${CommandType.FUNCTION_CALL}${instruction.object}.${instruction.method}(`

      // Add arguments
      const args = instruction.arguments
        .map((arg: any) => {
          if (arg.type === "Literal") {
            return `val:${arg.value}`
          } else if (arg.type === "Variable") {
            return `var:${arg.name}`
          }
          return "null"
        })
        .join(",")

      code += `${args})`

      // Store result if needed
      if (instruction.result !== undefined) {
        code += `${CommandType.VARIABLE_ACCESS}store:${instruction.result}`
      }

      return code + "\n"
    }
  }

  /**
   * Generates BrainForge code for creating arrays
   *
   * @param instruction - CreateArray instruction
   * @returns Generated BrainForge code
   */
  private generateCreateArrayCode(instruction: any): string {
    // Use BrainForge array creation command
    let code = `${CommandType.VARIABLE_ACCESS}array:${instruction.result}:[`

    // Add elements
    const elements = instruction.elements
      .map((element: any) => {
        if (element.type === "Literal") {
          return `val:${element.value}`
        } else if (element.type === "Variable") {
          return `var:${element.name}`
        }
        return "null"
      })
      .join(",")

    code += `${elements}]`

    return code + "\n"
  }

  /**
   * Generates BrainForge code for creating objects
   *
   * @param instruction - CreateObject instruction
   * @returns Generated BrainForge code
   */
  private generateCreateObjectCode(instruction: any): string {
    // Use BrainForge object creation command
    let code = `${CommandType.VARIABLE_ACCESS}object:${instruction.result}:{`

    // Add properties
    const properties = instruction.properties
      .map((prop: any) => {
        let value
        if (prop.value.type === "Literal") {
          value = `val:${prop.value.value}`
        } else if (prop.value.type === "Variable") {
          value = `var:${prop.value.name}`
        } else {
          value = "null"
        }

        return `${prop.key}:${value}`
      })
      .join(",")

    code += `${properties}}`

    return code + "\n"
  }

  /**
   * Generates a hash for a string (for object property lookup)
   *
   * @param str - String to hash
   * @returns Hash value
   */
  private hashString(str: string): number {
    let hash = 0
    for (let i = 0; i < str.length; i++) {
      hash = (hash << 5) - hash + str.charCodeAt(i)
      hash |= 0 // Convert to 32-bit integer
    }
    return Math.abs(hash)
  }

  /**
   * Generates BrainForge code for jumps
   *
   * @param instruction - Jump instruction
   * @returns Generated BrainForge code
   */
  private generateJumpCode(instruction: any): string {
    // In BrainForge, we'll use the @ extension for jumps
    //return `@${instruction.target}\n`
    return ""
  }

  /**
   * Generates BrainForge code for conditional jumps
   *
   * @param instruction - ConditionalJump instruction
   * @returns Generated BrainForge code
   */
  private generateConditionalJumpCode(instruction: any): string {
    // Use BrainForge conditional command
    let code = `${CommandType.CONDITIONAL}`

    // Test condition
    if (instruction.testAddress !== undefined) {
      code += `addr:${instruction.testAddress}`
    } else if (instruction.testValue !== undefined) {
      code += `val:${instruction.testValue}`
    }

    // True and false targets
    code += `:${instruction.trueTarget}:${instruction.falseTarget}`

    return code + "\n"
  }

  /**
   * Generates BrainForge code for if conditions
   *
   * @param instruction - IfCondition instruction
   * @returns Generated BrainForge code
   */
  private generateIfConditionCode(instruction: any): string {
    // Use BrainForge if command
    let code = `${CommandType.CONDITIONAL}if:`

    // Test condition
    if (instruction.testAddress !== undefined) {
      code += `addr:${instruction.testAddress}`
    } else if (instruction.testValue !== undefined) {
      code += `val:${instruction.testValue}`
    }

    // Then and else labels
    code += `:${instruction.thenLabel}:${instruction.elseLabel}`

    return code + "\n"
  }

  /**
   * Generates BrainForge code for return statements
   *
   * @param instruction - Return instruction
   * @returns Generated BrainForge code
   */
  private generateReturnCode(instruction: any): string {
    // Use BrainForge return command
    let code = `${CommandType.TYPE_CONVERSION}return:`

    // Return value
    if (instruction.address !== undefined) {
      code += `addr:${instruction.address}`
    } else if (instruction.value !== undefined) {
      code += `val:${instruction.value}`
    } else {
      code += "void"
    }

    return code + "\n"
  }

  /**
   * Generates BrainForge code for import statements
   *
   * @param instruction - Import instruction
   * @returns Generated BrainForge code
   */
  private generateImportCode(instruction: any): string {
    // In BrainForge, we'll use the & extension for imports
    //return `&${instruction.source}\n`
    return ""
  }

  /**
   * Generates BrainForge code for variable updates
   *
   * @param instruction - UpdateVariable instruction
   * @returns Generated BrainForge code
   */
  private generateUpdateVariableCode(instruction: any): string {
    // Use BrainForge variable update command
    return `${CommandType.VARIABLE_ACCESS}update:${instruction.address}:${instruction.operator}\n`
  }

  /**
   * Converts BrainForge code to standard Brainfuck
   *
   * @param bfCode - BrainForge code to convert
   * @returns Standard Brainfuck code
   */
  convertToStandardBrainfuck(bfCode: string): string {
    this.logger.debug("Converting BrainForge to standard Brainfuck")

    // Remove comments
    const code = bfCode.replace(/\/\/.*$/gm, "")

    // Create a transpiler for BrainForge to standard Brainfuck
    const transpiler = new BrainForgeToStandardBrainfuckTranspiler(this.logger)
    const standardBf = transpiler.convert(code)

    this.logger.debug("Conversion to standard Brainfuck complete")
    return standardBf
  }

  /**
   * Updates code generator options
   *
   * @param options - New options to apply
   */
  updateOptions(options: TranspilerOptions): void {
    this.options = options
  }
}

/**
 * Transpiler for converting BrainForge to standard Brainfuck
 */
class BrainForgeToStandardBrainfuckTranspiler {
  /** Logger instance */
  private logger: Logger

  /** Variable map */
  private variables: Map<string, number> = new Map()

  /** Next available memory address */
  private nextAddress = 0

  /**
   * Creates a new BrainForge to standard Brainfuck transpiler
   *
   * @param logger - Logger instance
   */
  constructor(logger: Logger) {
    this.logger = logger
  }

  /**
   * Converts BrainForge code to standard Brainfuck
   *
   * @param code - BrainForge code
   * @returns Standard Brainfuck code
   */
  convert(code: string): string {
    this.logger.debug("Converting BrainForge to standard Brainfuck")

    // Reset state
    this.variables.clear()
    this.nextAddress = 0

    let result = ""
    const lines = code.split("\n")

    for (const line of lines) {
      // Skip empty lines
      if (!line.trim()) continue

      // Process each line
      result += this.convertLine(line) + "\n"
    }

    // Remove non-Brainfuck characters
    result = result.replace(/[^+\-[\]<>.,]/g, "")

    return result
  }

  /**
   * Converts a line of BrainForge code to standard Brainfuck
   *
   * @param line - BrainForge code line
   * @returns Standard Brainfuck code
   */
  private convertLine(line: string): string {
    // If the line already contains only valid Brainfuck characters, return it as is
    if (/^[+\-[\]<>.,\s]*$/.test(line)) {
      return line
    }

    // Handle variable declaration
    if (line.startsWith(CommandType.VARIABLE_ACCESS)) {
      return this.handleVariableCommand(line)
    }

    // Handle function call
    if (line.startsWith(CommandType.FUNCTION_CALL)) {
      return this.handleFunctionCall(line)
    }

    // Handle conditional
    if (line.startsWith(CommandType.CONDITIONAL)) {
      return this.handleConditional(line)
    }

    // Handle string literal
    if (line.includes(CommandType.STRING_LITERAL)) {
      return this.handleStringLiteral(line)
    }

    // Handle other BrainForge commands
    if (this.isBrainForgeCommand(line)) {
      return this.convertBrainForgeCommand(line)
    }

    // Pass through standard Brainfuck
    return line
  }

  /**
   * Handles variable commands
   *
   * @param line - Variable command line
   * @returns Standard Brainfuck code
   */
  private handleVariableCommand(line: string): string {
    // For simplicity, just return a placeholder
    // In a real implementation, this would handle variable operations
    return "[-]"
  }

  /**
   * Handles function calls
   *
   * @param line - Function call line
   * @returns Standard Brainfuck code
   */
  private handleFunctionCall(line: string): string {
    // For simplicity, just return a placeholder
    // In a real implementation, this would handle function calls
    return "[-]"
  }

  /**
   * Handles conditional statements
   *
   * @param line - Conditional line
   * @returns Standard Brainfuck code
   */
  private handleConditional(line: string): string {
    // For simplicity, just return a placeholder
    // In a real implementation, this would handle conditionals
    return "[-]"
  }

  /**
   * Handles string literals
   *
   * @param line - String literal line
   * @returns Standard Brainfuck code
   */
  private handleStringLiteral(line: string): string {
    // Extract the string from between the backticks
    const match = line.match(/`(.*?)`/)
    if (!match) return "[-]"

    const str = match[1]
    let code = ""

    // Output each character
    for (let i = 0; i < str.length; i++) {
      const charCode = str.charCodeAt(i)
      code += `[-]${"+".repeat(charCode)}.`
    }

    return code
  }

  /**
   * Checks if a line contains BrainForge commands
   *
   * @param line - Code line
   * @returns True if the line contains BrainForge commands
   */
  private isBrainForgeCommand(line: string): boolean {
    const brainForgeCommands = Object.values(CommandType)
    return brainForgeCommands.some((cmd) => line.includes(cmd))
  }

  /**
   * Converts a BrainForge command to standard Brainfuck
   *
   * @param line - BrainForge command line
   * @returns Standard Brainfuck code
   */
  private convertBrainForgeCommand(line: string): string {
    // For simplicity, just return a placeholder
    // In a real implementation, this would convert BrainForge commands to standard Brainfuck
    return "[-]"
  }
}

